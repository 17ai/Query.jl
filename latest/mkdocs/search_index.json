{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Query\n\n\n\n\nOverview\n\n\nQuery allows you to execute queries against almost any julia data structure.\n\n\n\n\nInstallation\n\n\nThis package only works on julia 0.5- and newer. It is currently not registered, so you need to clone it:\n\n\nPkg.clone(\nhttps://github.com/davidanthoff/Query.jl.git\n)", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-query", 
            "text": "", 
            "title": "Welcome to Query"
        }, 
        {
            "location": "/#overview", 
            "text": "Query allows you to execute queries against almost any julia data structure.", 
            "title": "Overview"
        }, 
        {
            "location": "/#installation", 
            "text": "This package only works on julia 0.5- and newer. It is currently not registered, so you need to clone it:  Pkg.clone( https://github.com/davidanthoff/Query.jl.git )", 
            "title": "Installation"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Tutorial\n\n\n\n\nFirst steps\n\n\nYou can use Query to filter and transform columns from a $DataFrame$ and then create a new $DataFrame$ for the output:\n\n\nusing Query, DataFrames, NamedTuples\n\ndf = DataFrame(name=[\nJohn\n, \nSally\n, \nKirk\n], age=[23., 42., 59.], children=[3,5,2])\n\nx = @from i in df begin\n    @where i.age\n30. \n i.children \n 2\n    @select @NT(Name=\nlowercase(i.name))\n    @collect DataFrame\nend\n\nprintln(x)\n\n# output\n\n1\u00d71 DataFrames.DataFrame\n\u2502 Row \u2502 Name    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 \nsally\n \u2502\n\n\n\n\nYou don't have to start with a $DataFrame$, you can also query a $Dict$ and then collect the results into a $DataFrame$:\n\n\nusing Query, DataFrames, NamedTuples\n\nsource = Dict(\nJohn\n=\n34., \nSally\n=\n56.)\n\nresult = @from i in source begin\n         @where i.second\n36.\n         @select @NT(Name=\nlowercase(i.first))\n         @collect DataFrame\nend\n\nprintln(result)\n\n# output\n\n1\u00d71 DataFrames.DataFrame\n\u2502 Row \u2502 Name    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 \nsally\n \u2502\n\n\n\n\nOr you can start with just an array that holds some self-defined type:\n\n\nusing Query, DataFrames, NamedTuples\n\nimmutable Person\n    Name::String\n    Friends::Vector{String}\nend\n\nsource = Array(Person,0)\npush!(source, Person(\nJohn\n, [\nSally\n, \nMiles\n, \nFrank\n]))\npush!(source, Person(\nSally\n, [\nDon\n, \nMartin\n]))\n\nresult = @from i in source begin\n         @where length(i.Friends) \n 2\n         @select @NT( Name=\ni.Name, Friendcount=\nlength(i.Friends))\n         @collect DataFrame\nend\n\nprintln(result)\n\n# output\n\n1\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 Name   \u2502 Friendcount \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 \nJohn\n \u2502 3           \u2502\n\n\n\n\nYou also don't have to collect into a $DataFrame$, you can for example collect just one filtered column into an $Array$:\n\n\nusing Query, DataFrames, NamedTuples\n\ndf = DataFrame(name=[\nJohn\n, \nSally\n, \nKirk\n], age=[23., 42., 59.], children=[3,5,2])\n\nx = @from i in df begin\n    @where i.age\n30. \n i.children \n 2\n    @select lowercase(i.name)\n    @collect\nend\n\nprintln(x)\n\n# output\n\nString[\nsally\n]\n\n\n\n\nYou can also not collect at all and instead just iterate over the results of your query:\n\n\nusing Query, DataFrames, NamedTuples\n\ndf = DataFrame(name=[\nJohn\n, \nSally\n, \nKirk\n], age=[23., 42., 59.], children=[3,5,2])\n\nx = @from i in df begin\n    @where i.age\n30. \n i.children \n 2\n    @select @NT(Name=\nlowercase(i.name), Kids=\ni.children)\nend\n\nfor j in x\n    println(\n$(j.Name) has $(j.Kids) children.\n)\nend\n\n# output\n\nsally has 5 children.\n\n\n\n\n\n\n@let statement\n\n\nThe $@let$ statement allows you to define range variables inside your query:\n\n\nusing Query, DataFrames, NamedTuples\n\ndf = DataFrame(name=[\nJohn\n, \nSally\n, \nKirk\n], age=[23., 42., 59.], children=[3,5,2])\n\nx = @from i in df begin\n    @let name_length = length(i.name)\n    @where name_length \n= 4\n    @select @NT(Name=\nlowercase(i.name), Length=\nname_length)\n    @collect DataFrame\nend\n\nprintln(x)\n\n# output\n\n 2\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 Name   \u2502 Length \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 \njohn\n \u2502 4      \u2502\n\u2502 2   \u2502 \nkirk\n \u2502 4      \u2502\n\n\n\n\n\n\n@join statement\n\n\nThe $@join$ statement implements an inner join between two data sources. You can use this to join sources of different types. For example, below data from a $DataFrame$ and a $TypedTable$ are joined and the results are collected into a $DataFrame$:\n\n\nusing DataFrames, Query, NamedTuples, TypedTables\n\ndf1 = DataFrame(a=[1,2,3], b=[1.,2.,3.])\ndf2 = @Table(c=[2.,4.,2.], d=[\nJohn\n, \nJim\n,\nSally\n])\n\nx = @from i in df1 begin\n    @join j in df2 on i.a equals convert(Int,j.c)\n    @select @NT(a=\ni.a,b=\ni.b,c=\nj.c,d=\nj.d,e=\nName: $(j.d)\n)\n    @collect DataFrame\nend\n\nprintln(x)\n\n# output\n\n2\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 a \u2502 b   \u2502 c   \u2502 d       \u2502 e             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 2 \u2502 2.0 \u2502 2.0 \u2502 \nJohn\n  \u2502 \nName: John\n  \u2502\n\u2502 2   \u2502 2 \u2502 2.0 \u2502 2.0 \u2502 \nSally\n \u2502 \nName: Sally\n \u2502", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#tutorial", 
            "text": "", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#first-steps", 
            "text": "You can use Query to filter and transform columns from a $DataFrame$ and then create a new $DataFrame$ for the output:  using Query, DataFrames, NamedTuples\n\ndf = DataFrame(name=[ John ,  Sally ,  Kirk ], age=[23., 42., 59.], children=[3,5,2])\n\nx = @from i in df begin\n    @where i.age 30.   i.children   2\n    @select @NT(Name= lowercase(i.name))\n    @collect DataFrame\nend\n\nprintln(x)\n\n# output\n\n1\u00d71 DataFrames.DataFrame\n\u2502 Row \u2502 Name    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502  sally  \u2502  You don't have to start with a $DataFrame$, you can also query a $Dict$ and then collect the results into a $DataFrame$:  using Query, DataFrames, NamedTuples\n\nsource = Dict( John = 34.,  Sally = 56.)\n\nresult = @from i in source begin\n         @where i.second 36.\n         @select @NT(Name= lowercase(i.first))\n         @collect DataFrame\nend\n\nprintln(result)\n\n# output\n\n1\u00d71 DataFrames.DataFrame\n\u2502 Row \u2502 Name    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502  sally  \u2502  Or you can start with just an array that holds some self-defined type:  using Query, DataFrames, NamedTuples\n\nimmutable Person\n    Name::String\n    Friends::Vector{String}\nend\n\nsource = Array(Person,0)\npush!(source, Person( John , [ Sally ,  Miles ,  Frank ]))\npush!(source, Person( Sally , [ Don ,  Martin ]))\n\nresult = @from i in source begin\n         @where length(i.Friends)   2\n         @select @NT( Name= i.Name, Friendcount= length(i.Friends))\n         @collect DataFrame\nend\n\nprintln(result)\n\n# output\n\n1\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 Name   \u2502 Friendcount \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502  John  \u2502 3           \u2502  You also don't have to collect into a $DataFrame$, you can for example collect just one filtered column into an $Array$:  using Query, DataFrames, NamedTuples\n\ndf = DataFrame(name=[ John ,  Sally ,  Kirk ], age=[23., 42., 59.], children=[3,5,2])\n\nx = @from i in df begin\n    @where i.age 30.   i.children   2\n    @select lowercase(i.name)\n    @collect\nend\n\nprintln(x)\n\n# output\n\nString[ sally ]  You can also not collect at all and instead just iterate over the results of your query:  using Query, DataFrames, NamedTuples\n\ndf = DataFrame(name=[ John ,  Sally ,  Kirk ], age=[23., 42., 59.], children=[3,5,2])\n\nx = @from i in df begin\n    @where i.age 30.   i.children   2\n    @select @NT(Name= lowercase(i.name), Kids= i.children)\nend\n\nfor j in x\n    println( $(j.Name) has $(j.Kids) children. )\nend\n\n# output\n\nsally has 5 children.", 
            "title": "First steps"
        }, 
        {
            "location": "/tutorial/#let-statement", 
            "text": "The $@let$ statement allows you to define range variables inside your query:  using Query, DataFrames, NamedTuples\n\ndf = DataFrame(name=[ John ,  Sally ,  Kirk ], age=[23., 42., 59.], children=[3,5,2])\n\nx = @from i in df begin\n    @let name_length = length(i.name)\n    @where name_length  = 4\n    @select @NT(Name= lowercase(i.name), Length= name_length)\n    @collect DataFrame\nend\n\nprintln(x)\n\n# output\n\n 2\u00d72 DataFrames.DataFrame\n\u2502 Row \u2502 Name   \u2502 Length \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502  john  \u2502 4      \u2502\n\u2502 2   \u2502  kirk  \u2502 4      \u2502", 
            "title": "@let statement"
        }, 
        {
            "location": "/tutorial/#join-statement", 
            "text": "The $@join$ statement implements an inner join between two data sources. You can use this to join sources of different types. For example, below data from a $DataFrame$ and a $TypedTable$ are joined and the results are collected into a $DataFrame$:  using DataFrames, Query, NamedTuples, TypedTables\n\ndf1 = DataFrame(a=[1,2,3], b=[1.,2.,3.])\ndf2 = @Table(c=[2.,4.,2.], d=[ John ,  Jim , Sally ])\n\nx = @from i in df1 begin\n    @join j in df2 on i.a equals convert(Int,j.c)\n    @select @NT(a= i.a,b= i.b,c= j.c,d= j.d,e= Name: $(j.d) )\n    @collect DataFrame\nend\n\nprintln(x)\n\n# output\n\n2\u00d75 DataFrames.DataFrame\n\u2502 Row \u2502 a \u2502 b   \u2502 c   \u2502 d       \u2502 e             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1   \u2502 2 \u2502 2.0 \u2502 2.0 \u2502  John   \u2502  Name: John   \u2502\n\u2502 2   \u2502 2 \u2502 2.0 \u2502 2.0 \u2502  Sally  \u2502  Name: Sally  \u2502", 
            "title": "@join statement"
        }, 
        {
            "location": "/internals/", 
            "text": "Internals\n\n\n\n\nOverview\n\n\nThis package is modeled closely after LINQ. If you are not familiar with LINQ, \nthis\n is a great overview. It is especially recommended if you associate LINQ mainly with a query syntax in a language and don't know about the underlying language features and architecture, for example how anonymous types, lambdas and lots of other language features all play together. The query syntax is really just the tip of the iceberg.\n\n\nThe core idea of this package right now is to iterate over $NamedTuple$s for table like data structures. Starting with a $DataFrame$, $query$ will create an iterator that produces a $NamedTuple$ that has a field for each column, and the $collect$ method can turn a stream of $NamedTuple$s back into a $DataFrame$.\n\n\nIf one starts with a queryable data source (like SQLite), the query will automatically be translated into SQL and executed in the database.\n\n\nThe wording of methods and types currently follows LINQ, not julia conventions. This is mainly to prevent clashes while Query.jl is in development.\n\n\n\n\nReadings\n\n\nThe original \nLINQ\n document is still a good read.\n\n\nThe \nThe Wayward WebLog\n has some excellent posts about writing query providers:\n\n\n\n\nLINQ: Building an IQueryable Provider \u2013 Part I\n\n\nLINQ: Building an IQueryable Provider \u2013 Part II\n\n\nLINQ: Building an IQueryable Provider \u2013 Part III\n\n\nLINQ: Building an IQueryable Provider \u2013 Part IV\n\n\nLINQ: Building an IQueryable Provider \u2013 Part V\n\n\nLINQ: Building an IQueryable Provider \u2013 Part VI\n\n\nLINQ: Building an IQueryable provider \u2013 Part VII\n\n\nLINQ: Building an IQueryable Provider \u2013 Part VIII\n\n\nLINQ: Building an IQueryable Provider \u2013 Part IX\n\n\nLINQ: Building an IQueryable Provider \u2013 Part X\n\n\nLINQ: Building an IQueryable Provider \u2013 Part XI\n\n\nBuilding a LINQ IQueryable Provider \u2013 Part XII\n\n\nBuilding a LINQ IQueryable Provider \u2013 Part XIII\n\n\nBuilding a LINQ IQueryable provider \u2013 Part XIV\n\n\nBuilding a LINQ IQueryable provider \u2013 Part XV (IQToolkit v0.15)\n\n\nBuilding a LINQ IQueryable Provider \u2013 Part XVI (IQToolkit 0.16)\n\n\nBuilding a LINQ IQueryable Provider \u2013 Part XVII (IQToolkit 0.17)\n\n\n\n\nJoe Duffy\n wrote an interesting article about iterator protocolls: - \nJoe Duffy on enumerating in .Net", 
            "title": "Internals"
        }, 
        {
            "location": "/internals/#internals", 
            "text": "", 
            "title": "Internals"
        }, 
        {
            "location": "/internals/#overview", 
            "text": "This package is modeled closely after LINQ. If you are not familiar with LINQ,  this  is a great overview. It is especially recommended if you associate LINQ mainly with a query syntax in a language and don't know about the underlying language features and architecture, for example how anonymous types, lambdas and lots of other language features all play together. The query syntax is really just the tip of the iceberg.  The core idea of this package right now is to iterate over $NamedTuple$s for table like data structures. Starting with a $DataFrame$, $query$ will create an iterator that produces a $NamedTuple$ that has a field for each column, and the $collect$ method can turn a stream of $NamedTuple$s back into a $DataFrame$.  If one starts with a queryable data source (like SQLite), the query will automatically be translated into SQL and executed in the database.  The wording of methods and types currently follows LINQ, not julia conventions. This is mainly to prevent clashes while Query.jl is in development.", 
            "title": "Overview"
        }, 
        {
            "location": "/internals/#readings", 
            "text": "The original  LINQ  document is still a good read.  The  The Wayward WebLog  has some excellent posts about writing query providers:   LINQ: Building an IQueryable Provider \u2013 Part I  LINQ: Building an IQueryable Provider \u2013 Part II  LINQ: Building an IQueryable Provider \u2013 Part III  LINQ: Building an IQueryable Provider \u2013 Part IV  LINQ: Building an IQueryable Provider \u2013 Part V  LINQ: Building an IQueryable Provider \u2013 Part VI  LINQ: Building an IQueryable provider \u2013 Part VII  LINQ: Building an IQueryable Provider \u2013 Part VIII  LINQ: Building an IQueryable Provider \u2013 Part IX  LINQ: Building an IQueryable Provider \u2013 Part X  LINQ: Building an IQueryable Provider \u2013 Part XI  Building a LINQ IQueryable Provider \u2013 Part XII  Building a LINQ IQueryable Provider \u2013 Part XIII  Building a LINQ IQueryable provider \u2013 Part XIV  Building a LINQ IQueryable provider \u2013 Part XV (IQToolkit v0.15)  Building a LINQ IQueryable Provider \u2013 Part XVI (IQToolkit 0.16)  Building a LINQ IQueryable Provider \u2013 Part XVII (IQToolkit 0.17)   Joe Duffy  wrote an interesting article about iterator protocolls: -  Joe Duffy on enumerating in .Net", 
            "title": "Readings"
        }
    ]
}